// Generated by CoffeeScript 1.4.0
var assert, diamond, id;

assert = require('assert');

diamond = require('./diamond');

id = function(x) {
  return x;
};

exports.create = function() {
  var bindings_, contents_, modes_, omap_, omap_is_prefix_, type_, type_unshift_, with_movement_, _ref;
  contents_ = (function() {
    var after_fixing_cursor, col, col_max_adjustment, fixed_cursor, line, lines;
    lines = [[]];
    line = col = col_max_adjustment = 0;
    fixed_cursor = function() {
      var c, corral, l;
      corral = function(n, min, max) {
        return Math.max(min, Math.min(max, n));
      };
      l = corral(line, 0, lines.length - 1);
      c = corral(col, 0, lines[line].length - 1 + col_max_adjustment);
      return [l, c];
    };
    after_fixing_cursor = function(f) {
      var _ref;
      _ref = fixed_cursor(), line = _ref[0], col = _ref[1];
      return f();
    };
    return id({
      insert_char: function(c) {
        if (c === diamond.BS) {
          return after_fixing_cursor(function() {
            if (col !== 0) {
              lines[line].splice(col - 1, 1);
              return col--;
            }
          });
        } else if (c === diamond.LEFT) {
          return after_fixing_cursor(function() {
            return col--;
          });
        } else if (c === diamond.RIGHT) {
          return after_fixing_cursor(function() {
            return col++;
          });
        } else if (c === diamond.UP) {
          if (line > 0) {
            return line--;
          }
        } else if (c === diamond.DOWN) {
          if (line < lines.length - 1) {
            return line++;
          }
        } else if (c === diamond.CR) {
          return after_fixing_cursor(function() {
            var new_line;
            new_line = lines[line].splice(col, lines[line].length - col);
            lines.splice(++line, 0, new_line);
            return col = 0;
          });
        } else {
          return after_fixing_cursor(function() {
            return lines[line].splice(++col - 1, 0, c);
          });
        }
      },
      cursor: fixed_cursor,
      set_cursor: function(l, c) {
        var _ref;
        return _ref = [l, c], line = _ref[0], col = _ref[1], _ref;
      },
      move_cursor_to_end_of_line: function() {
        return after_fixing_cursor(function() {
          return col = lines[line].length - 1 + col_max_adjustment;
        });
      },
      move_cursor_to_beginning_of_line: function() {
        return after_fixing_cursor(function() {
          return col = 0;
        });
      },
      allow_cursor_eol: function(allow) {
        return col_max_adjustment = allow ? 1 : 0;
      },
      to_string: function() {
        var l;
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = lines.length; _i < _len; _i++) {
            l = lines[_i];
            _results.push(l.join(''));
          }
          return _results;
        })()).join('\n');
      },
      delete_at_cursor: function(_arg) {
        var dc, dl;
        dl = _arg[0], dc = _arg[1];
        return after_fixing_cursor(function() {
          var _ref, _ref1;
          if (dl !== null) {
            if (line + dl < 0) {
              return;
            }
            if (line + dl > lines.length) {
              return;
            }
            if (dl < 0) {
              _ref = [line + dl, Math.abs(dl)], line = _ref[0], dl = _ref[1];
            }
            lines.splice(line, dl + 1);
            line = Math.min(line, lines.length - 1);
            return col = 0;
          } else {
            if (col + dc < 0) {
              return;
            }
            if (col + dc > lines[line].length + col_max_adjustment) {
              return;
            }
            if (dc < 0) {
              _ref1 = [col + dc, Math.abs(dc)], col = _ref1[0], dc = _ref1[1];
            }
            return lines[line].splice(col, dc);
          }
        });
      }
    });
  })();
  bindings_ = (function() {
    var tree;
    tree = {};
    return {
      concat: function(keys, more_keys) {
        var t;
        t = function(k) {
          if (typeof k === 'string') {
            return k = diamond.tokenize(k);
          } else {
            return k;
          }
        };
        return t(keys).concat(t(more_keys));
      },
      map: function(keys, cob, t) {
        var COB_KEY, k, _ref, _ref1, _ref2;
        if (cob == null) {
          cob = null;
        }
        if (t == null) {
          t = tree;
        }
        if (keys.length === 0) {
          COB_KEY = 'map_:COB_KEY';
          if (cob != null) {
            return t[COB_KEY] = cob;
          } else {
            return (_ref = t[COB_KEY]) != null ? _ref : null;
          }
        }
        _ref1 = [keys[0], keys.slice(1)], k = _ref1[0], keys = _ref1[1];
        if (cob != null) {
          return bindings_.map(keys, cob, (_ref2 = t[k]) != null ? _ref2 : t[k] = {});
        } else if (t[k] != null) {
          return bindings_.map(keys, cob, t[k]);
        } else {
          return null;
        }
      },
      is_prefix: function(keys, t) {
        var k, _ref;
        if (t == null) {
          t = tree;
        }
        if (keys.length === 0) {
          return t != null;
        }
        _ref = [keys[0], keys.slice(1)], k = _ref[0], keys = _ref[1];
        return (t[k] != null) && bindings_.is_prefix(keys, t[k]);
      }
    };
  })();
  modes_ = (function() {
    var create_mode, current_mode, imode, nmode, onchange_cobs, set_mode, _ref;
    create_mode = function(name) {
      return (function() {
        var MODE_KEY;
        MODE_KEY = "modes_:" + name;
        return {
          NAME: name,
          map: function(keys, cob) {
            if (cob == null) {
              cob = null;
            }
            return bindings_.map(bindings_.concat([MODE_KEY], keys), cob);
          },
          is_prefix: function(keys) {
            return bindings_.is_prefix([MODE_KEY].concat(keys));
          }
        };
      })();
    };
    nmode = create_mode('NORMAL');
    imode = create_mode('INSERT');
    _ref = [nmode, []], current_mode = _ref[0], onchange_cobs = _ref[1];
    set_mode = function(new_mode) {
      var cob, old_mode, _i, _len, _results;
      old_mode = modes_.current();
      current_mode = new_mode;
      _results = [];
      for (_i = 0, _len = onchange_cobs.length; _i < _len; _i++) {
        cob = onchange_cobs[_i];
        _results.push(cob(old_mode.NAME, new_mode.NAME));
      }
      return _results;
    };
    nmode.map('i', function() {
      return set_mode(imode);
    });
    imode.map('<esc>', function() {
      return set_mode(nmode);
    });
    return id({
      NORMAL: 'NORMAL',
      INSERT: 'INSERT',
      nmap: nmode.map,
      imap: imode.map,
      current: function() {
        return current_mode;
      },
      onchange: function(cob) {
        return onchange_cobs.push(cob);
      }
    });
  })();
  omap_ = function(keys, cob) {
    return bindings_.map(bindings_.concat(['omap_'], keys), cob);
  };
  omap_is_prefix_ = function(keys) {
    return bindings_.is_prefix(bindings_.concat(['omap_'], keys));
  };
  modes_.onchange(function(old_mode, new_mode) {
    if (old_mode === modes_.INSERT && new_mode === modes_.NORMAL) {
      contents_.insert_char(diamond.LEFT);
    }
    return contents_.allow_cursor_eol(new_mode === modes_.INSERT);
  });
  _ref = (function() {
    var HANDLED, IS_PREFIX, UNHANDLED, already_typing, pending, prefix, to_type, type, type_unshift, with_movement;
    HANDLED = 'pending:handled';
    IS_PREFIX = 'pending:not_handled_but_is_prefix';
    UNHANDLED = 'pending:unhandled_and_is_not_prefix';
    to_type = [];
    prefix = [];
    pending = [];
    already_typing = false;
    type = function(keys) {
      var cob, k, not_known_prefix, p, p_result, _i, _j, _len, _len1, _ref;
      _ref = diamond.tokenize(keys);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        to_type.push(k);
      }
      if (already_typing) {
        return;
      }
      already_typing = true;
      while (to_type.length > 0) {
        prefix.push(to_type.shift());
        not_known_prefix = !modes_.current().is_prefix(prefix);
        cob = modes_.current().map(prefix);
        for (_j = 0, _len1 = pending.length; _j < _len1; _j++) {
          p = pending[_j];
          p_result = p();
          if (p_result === HANDLED) {
            prefix = [];
            pending = [];
            cob = null;
            break;
          } else if (p_result === IS_PREFIX) {
            not_known_prefix = false;
          }
        }
        if ((cob != null) && cob() !== false) {
          not_known_prefix = false;
          prefix = [];
          pending = [];
        }
        if (prefix.length !== 0 && modes_.current().NAME === modes_.INSERT) {
          assert.equal(1, prefix.length);
          contents_.insert_char(prefix.shift());
          not_known_prefix = false;
        }
        if (not_known_prefix) {
          prefix = [];
          pending = [];
        }
      }
      return already_typing = false;
    };
    type_unshift = function(keys) {
      to_type = diamond.tokenize(keys).concat(to_type);
      return type('');
    };
    with_movement = function(cob) {
      var pending_length, pending_queue_length;
      pending_length = prefix.length;
      pending_queue_length = pending.length;
      pending.push(function() {
        var movement_cob, remainder;
        remainder = prefix.slice(pending_length);
        movement_cob = omap_(remainder);
        if (movement_cob != null) {
          cob(movement_cob());
          return HANDLED;
        } else if (omap_is_prefix_(remainder)) {
          return IS_PREFIX;
        } else {
          return UNHANDLED;
        }
      });
      return false;
    };
    return [type_unshift, type, with_movement];
  })(), type_unshift_ = _ref[0], type_ = _ref[1], with_movement_ = _ref[2];
  (function() {
    var delete_at_cursor, imap, insert_char, nmap, omap, set_cursor;
    nmap = function(keys, cob) {
      if (typeof cob === 'string') {
        cob = (function(cob) {
          return function() {
            return type_unshift_(cob);
          };
        })(cob);
      }
      return modes_.nmap(keys, cob);
    };
    imap = modes_.imap;
    set_cursor = contents_.set_cursor, insert_char = contents_.insert_char, delete_at_cursor = contents_.delete_at_cursor;
    omap = omap_;
    nmap('a', 'i<right>');
    nmap('A', '$a');
    nmap('$', function() {
      return contents_.move_cursor_to_end_of_line();
    });
    nmap('0', function() {
      return contents_.move_cursor_to_beginning_of_line();
    });
    nmap('o', 'A<cr>');
    nmap('O', '0i<cr><up>');
    nmap('h', function() {
      return insert_char(diamond.LEFT);
    });
    omap('h', function() {
      return [null, -1];
    });
    nmap('l', function() {
      return insert_char(diamond.RIGHT);
    });
    omap('l', function() {
      return [null, +1];
    });
    nmap('j', function() {
      return insert_char(diamond.DOWN);
    });
    omap('j', function() {
      return [+1, 0];
    });
    nmap('k', function() {
      return insert_char(diamond.UP);
    });
    omap('k', function() {
      return [-1, 0];
    });
    nmap('x', 'dl');
    nmap('gg', function() {
      return set_cursor(0, 0);
    });
    omap('gg', function() {
      return [-contents_.cursor()[0], 0];
    });
    return nmap('d', function() {
      return with_movement_(function(m) {
        return delete_at_cursor(m);
      });
    });
  })();
  return {
    contents: contents_.to_string,
    mode: function() {
      return modes_.current().NAME;
    },
    cursor: contents_.cursor,
    type: type_
  };
};
