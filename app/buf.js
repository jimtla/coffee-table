// Generated by CoffeeScript 1.4.0
var assert, diamond, id;

assert = require('assert');

diamond = require('./diamond');

id = function(x) {
  return x;
};

exports.create = function() {
  var bindings_, contents_, modes_, omap_, type_;
  contents_ = (function() {
    var after_fixing_cursor, col, col_max_adjustment, fixed_cursor, line, lines;
    lines = [[]];
    line = col = col_max_adjustment = 0;
    fixed_cursor = function() {
      var c, corral, l;
      corral = function(n, min, max) {
        return Math.max(min, Math.min(max, n));
      };
      l = corral(line, 0, lines.length - 1);
      c = corral(col, 0, lines[line].length - 1 + col_max_adjustment);
      return [l, c];
    };
    after_fixing_cursor = function(f) {
      var _ref;
      _ref = fixed_cursor(), line = _ref[0], col = _ref[1];
      return f();
    };
    return id({
      insert_char: function(c) {
        return after_fixing_cursor(function() {
          lines[line].splice(++col - 1, 0, c);
          if (c === diamond.CR) {
            lines.splice(++line, 0, []);
            return col = 0;
          }
        });
      },
      cursor: fixed_cursor,
      displace_col: function(dc) {
        return after_fixing_cursor(function() {
          return col += dc;
        });
      },
      set_cursor: function(l, c) {
        var _ref;
        return _ref = [l, c], line = _ref[0], col = _ref[1], _ref;
      },
      allow_cursor_eol: function(allow) {
        return col_max_adjustment = allow ? 1 : 0;
      },
      to_string: function() {
        var l;
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = lines.length; _i < _len; _i++) {
            l = lines[_i];
            _results.push(l.join(''));
          }
          return _results;
        })()).join('');
      },
      x: function() {
        return after_fixing_cursor(function() {
          return lines[line].splice(col, 1);
        });
      }
    });
  })();
  bindings_ = (function() {
    var tree;
    tree = {};
    return {
      concat: function(keys, more_keys) {
        var t;
        t = function(k) {
          if (typeof k === 'string') {
            return k = diamond.tokenize(k);
          } else {
            return k;
          }
        };
        return t(keys).concat(t(more_keys));
      },
      map: function(keys, cob, t) {
        var COB_KEY, k, _ref, _ref1, _ref2;
        if (cob == null) {
          cob = null;
        }
        if (t == null) {
          t = tree;
        }
        if (keys.length === 0) {
          COB_KEY = 'map_:COB_KEY';
          if (cob != null) {
            return t[COB_KEY] = cob;
          } else {
            return (_ref = t[COB_KEY]) != null ? _ref : null;
          }
        }
        _ref1 = [keys[0], keys.slice(1)], k = _ref1[0], keys = _ref1[1];
        if (cob != null) {
          return bindings_.map(keys, cob, (_ref2 = t[k]) != null ? _ref2 : t[k] = {});
        } else if (t[k] != null) {
          return bindings_.map(keys, cob, t[k]);
        } else {
          return null;
        }
      },
      is_prefix: function(keys, t) {
        var k, _ref;
        if (t == null) {
          t = tree;
        }
        if (keys.length === 0) {
          return t != null;
        }
        _ref = [keys[0], keys.slice(1)], k = _ref[0], keys = _ref[1];
        return (t[k] != null) && bindings_.is_prefix(keys, t[k]);
      }
    };
  })();
  modes_ = (function() {
    var create_mode, current_mode, imode, nmode, onchange_cobs, set_mode, _ref;
    create_mode = function(name) {
      return (function() {
        var MODE_KEY;
        MODE_KEY = "modes_:" + name;
        return {
          NAME: name,
          map: function(keys, cob) {
            if (cob == null) {
              cob = null;
            }
            return bindings_.map(bindings_.concat([MODE_KEY], keys), cob);
          },
          is_prefix: function(keys) {
            return bindings_.is_prefix([MODE_KEY].concat(keys));
          }
        };
      })();
    };
    nmode = create_mode('NORMAL');
    imode = create_mode('INSERT');
    _ref = [nmode, []], current_mode = _ref[0], onchange_cobs = _ref[1];
    set_mode = function(new_mode) {
      var cob, old_mode, _i, _len, _results;
      old_mode = modes_.current();
      current_mode = new_mode;
      _results = [];
      for (_i = 0, _len = onchange_cobs.length; _i < _len; _i++) {
        cob = onchange_cobs[_i];
        _results.push(cob(old_mode.NAME, new_mode.NAME));
      }
      return _results;
    };
    nmode.map('i', function() {
      return set_mode(imode);
    });
    imode.map('<esc>', function() {
      return set_mode(nmode);
    });
    return id({
      NORMAL: 'NORMAL',
      INSERT: 'INSERT',
      nmap: nmode.map,
      imap: imode.map,
      current: function() {
        return current_mode;
      },
      onchange: function(cob) {
        return onchange_cobs.push(cob);
      }
    });
  })();
  omap_ = function(keys, cob) {
    return bindings_.map(bindings_.concat(['omap_'], keys), cob);
  };
  (function() {
    return omap_('h', function() {
      return -1;
    });
  })();
  modes_.onchange(function(old_mode, new_mode) {
    if (old_mode === modes_.INSERT && new_mode === modes_.NORMAL) {
      contents_.displace_col(-1);
    }
    return contents_.allow_cursor_eol(new_mode === modes_.INSERT);
  });
  type_ = (function() {
    var prefix;
    prefix = [];
    return function(keys) {
      var cob, k, not_known_prefix, _i, _len, _ref, _results;
      _ref = diamond.tokenize(keys);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        prefix.push(k);
        not_known_prefix = !modes_.current().is_prefix(prefix);
        cob = modes_.current().map(prefix);
        if (cob != null) {
          prefix = [];
          cob();
          not_known_prefix = false;
        }
        if (prefix.length !== 0 && modes_.current().NAME === modes_.INSERT) {
          assert.equal(1, prefix.length);
          contents_.insert_char(prefix.shift());
          not_known_prefix = false;
        }
        if (not_known_prefix) {
          _results.push(prefix = []);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  })();
  (function() {
    var displace_col, imap, insert_char, nmap, set_cursor, x;
    nmap = modes_.nmap, imap = modes_.imap;
    displace_col = contents_.displace_col, set_cursor = contents_.set_cursor, insert_char = contents_.insert_char, x = contents_.x;
    nmap('a', function() {
      return type_('i<right>');
    });
    nmap('h', function() {
      return displace_col(-1);
    });
    nmap('l', function() {
      return displace_col(+1);
    });
    nmap('x', function() {
      return x();
    });
    nmap('gg', function() {
      return set_cursor(0, 0);
    });
    return imap('<right>', function() {
      return displace_col(+1);
    });
  })();
  return {
    contents: contents_.to_string,
    mode: function() {
      return modes_.current().NAME;
    },
    cursor: contents_.cursor,
    type: type_
  };
};
